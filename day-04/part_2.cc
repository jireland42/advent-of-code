#include <fstream>
#include <iostream>
#include <algorithm>
#include <string>
#include <sstream>
#include <vector>

constexpr int num_player_numbers{10};
constexpr int num_winning_numbers{25};
//constexpr int num_player_numbers{5};
//constexpr int num_winning_numbers{8};

auto get_index(size_t row, size_t col, size_t num_cards) -> size_t
{
	return row * num_cards + col;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		std::cout << "Usage: ./part_1 input_file\n";
		return 1;
	}

	char* file_name{argv[1]};
	std::ifstream input_file(file_name);
	std::string line{};

	std::string card;
	int card_id_number;
	std::string colon;
	std::string pipe;
	int card_number;

	std::vector <int> player_numbers;
	std::vector <int> winning_numbers;

	std::vector <int> won_cards_table (2, 0); // extra row of zeros for edge case
	size_t won_cards_table_width{0};

	int total_cards{0};

	while (std::getline(input_file, line))
	{
		// read data from line into variables and store the tow sets of numbers

		std::istringstream iss{line};
		iss >> card >> card_id_number >> colon;

		for (int i{0}; i < num_player_numbers; i += 1)
		{
			iss >> card_number;
			player_numbers.emplace_back(card_number);
			std::sort(player_numbers.begin(), player_numbers.end());
		}

		iss >> pipe;

		for (int i{0}; i < num_winning_numbers; i += 1)
		{
			iss >> card_number;
			winning_numbers.emplace_back(card_number);
			std::sort(winning_numbers.begin(), winning_numbers.end());
		}

		int player_index{0};
		int winners_index{0};
		size_t matches{0};

		// find matches
		for (;;)
		{
			int player_number{player_numbers[player_index]};
			int winning_number{winning_numbers[winners_index]};


			if (player_number == winning_number)
			{
				player_index += 1;
				winners_index += 1;

				matches += 1;

				if (player_index == num_player_numbers || winners_index == num_winning_numbers) { break; }
			}
			else if (player_number < winning_number)
			{
				player_index += 1;

				if (player_index == num_player_numbers) { break; }
			}
			else
			{
				winners_index += 1;

				if (winners_index == num_winning_numbers) { break; }
			}
		}

		int cards_from_previous_round{won_cards_table[1]};
		int cards_with_current_id{1 + cards_from_previous_round};

		// set the number of copies of the card with the current ID
		won_cards_table[0] = cards_with_current_id;

		// add the copies of cards that will be encountered later to the copies
		// generated from previous rounds
		for (size_t i{0}; i < matches; i += 1)
		{
			if (i + 2 < won_cards_table.size())
			{
				// add cards generated by current card and cards gerated by previous cards
				won_cards_table[i + 1] = cards_with_current_id + won_cards_table[i + 2];
			}
			else if (i + 1 < won_cards_table.size())
			{
				// add cards generated by current card since no cards generated in previous rounds
				won_cards_table[i + 1] = cards_with_current_id;
			}
			else
			{
				// add cards generated by current card, accounting for when the
				// array is too small to hold all the elements
				won_cards_table.emplace_back(cards_with_current_id);
			}
		}

		// track the table width to know how to forward the cards generated from
		// previous game rounds
		if (matches + 1 >= won_cards_table_width) { won_cards_table_width = matches + 1; }
		else { won_cards_table_width -= 1; }

		// copy remaining generated cards counts to new spot in array
		size_t i{matches + 1};
		for (; i < won_cards_table_width; i += 1) { won_cards_table[i] = won_cards_table[i + 1]; }

		// if the final value was not overwritten, then we need to clear its value
		if (won_cards_table_width < won_cards_table.size()) { won_cards_table[i] = 0; }

		total_cards += cards_with_current_id;

		// reset containers for next iteration
		matches = 0;
		player_numbers.clear();
		winning_numbers.clear();
	}

	std::cout << '\n' << "Total Cards: " << total_cards << '\n';

	return 0;
}

